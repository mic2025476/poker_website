{% load i18n %}

<form id="bookingForm" method="POST" novalidate>
  {% csrf_token %}

  <!-- Step 1: Booking Date and Time -->
  <div class="form-step active" data-step="1">
    <div class="mb-3">
      <p class="fw-bold text-dark mb-2 small">
        <i class="fas fa-calendar-day text-danger me-1"></i>
        {% trans "Select Your Day" %}
      </p>

      <div class="mb-2">
        <label for="bookingDate" class="form-label fw-semibold small">
          <i class="fas fa-calendar-alt me-1"></i>{% trans "Booking Date" %}
        </label>
        <input type="date" class="form-control" id="bookingDate" name="booking_date" required />
        <div id="dateAvailabilityMessage" class="small mt-1"></div>
      </div>

      <div class="row">
<div class="col-md-6 mb-3">
  <label class="form-label fw-semibold small">
    <i class="fas fa-clock me-1"></i>{% trans "Start Time" %}
  </label>

  <p class="form-text text-muted small mb-1">
    <i class="fas fa-info-circle me-1"></i>
    {% trans "Start time is fixed: 18:00 – 12:00 the next day." %}
  </p>

  <!-- Hidden select, always 18:00 -->
  <select class="form-select d-none" id="bookingTime" name="booking_time">
    <option value="18:00" selected>18:00</option>
  </select>

  <!-- Optional: keep but hide the old message -->
  <div class="form-text text-muted mt-1 small d-none" id="timeSlotMessage">
    <i class="fas fa-info-circle me-1"></i>
    {% trans "Available start times based on MGEN-F24 calendar" %}
  </div>
</div>


<div class="col-md-6 mb-3">
  <label class="form-label fw-semibold small">
    <i class="fas fa-hourglass-half me-1"></i>{% trans "Duration" %}
  </label>

  <!-- Keep the select for JS/backend, but hide it and prefill with 18 -->
  <select class="form-select d-none" id="bookingDuration" name="number_of_hours">
    <option value="18" selected>18</option>
  </select>

  <!-- Optional: you can remove this if you don't need it anymore -->
  <div class="form-text text-muted mt-1 small d-none" id="durationMessage">
    <i class="fas fa-info-circle me-1"></i>
    {% trans "Available hours based on selected time" %}
  </div>
</div>

      </div>
    </div>
  </div>

  <!-- Step 2: Number of People and Services -->
  <div class="form-step" data-step="2">
    <div class="mb-3">
      <p class="fw-bold text-dark mb-2 small">
        <i class="fas fa-users text-danger me-1"></i>
        {% trans "People & Services" %}
      </p>

      <div class="mb-3">
        <label for="numberOfPeople" class="form-label fw-semibold small">
          <i class="fas fa-user-friends me-1"></i>{% trans "Number of People" %}
        </label>
        <input type="number" class="form-control" id="numberOfPeople" name="number_of_people" min="1" max="50" required />
        <div class="form-text text-muted small">
          {% trans "Maximum capacity: 50 people" %}
        </div>
      </div>

      <div class="mb-3">
        <label class="form-label fw-semibold small mb-2">
          <i class="fas fa-concierge-bell me-1"></i>{% trans "Additional Services" %}
        </label>
        <div class="row g-2">
          <div class="col-12">
            <div class="form-check p-2 border rounded">
              <input class="form-check-input" type="checkbox" id="dealerService" name="services" value="dealer">
              <label class="form-check-label fw-semibold small" for="dealerService">
                <i class="fas fa-user-tie me-1"></i>{% trans "Professional Dealer" %}
                <div class="text-muted small">{% trans "+€238 - Expert poker dealer for your session" %}</div>
              </label>
            </div>
          </div>
          <div class="col-12">
            <div class="form-check p-2 border rounded">
              <input class="form-check-input" type="checkbox" id="servicePersonal" name="services" value="service">
              <label class="form-check-label fw-semibold small" for="servicePersonal">
                <i class="fas fa-user-cog me-1"></i>{% trans "Service Personal" %}
                <div class="text-muted small">{% trans "+€238 - Dedicated service staff for your event" %}</div>
              </label>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Step 3: Drinks and Payment -->
  <div class="form-step" data-step="3">
    <div class="mb-3">
      <p class="fw-bold text-dark mb-2 small">
        <i class="fas fa-cocktail text-danger me-1"></i>
        {% trans "Drinks & Payment" %}
      </p>

      <div class="mb-3">
        <label class="form-label fw-semibold small mb-2">
          <i class="fas fa-glass-cheers me-1"></i>{% trans "Beverage Options" %}
        </label>
        <div class="mb-3">
          <div class="form-check p-2 border rounded">
            <input class="form-check-input" type="checkbox" id="drinksFlatrate" name="drinks_flatrate" value="flatrate">
            <label class="form-check-label fw-semibold small" for="drinksFlatrate">
              <i class="fas fa-wine-bottle me-1"></i>{% trans "Drinks Flatrate" %}
              <div class="text-muted small">{% trans "+€238 - Unlimited beverages for your group" %}</div>
            </label>
          </div>
        </div>

        <div class="alert alert-info">
          <i class="fas fa-info-circle me-2"></i>
          <strong>{% trans "Individual Drinks:" %}</strong> {% trans "Available for purchase separately during your event" %}
        </div>

        <div class="mb-3">
          <label class="form-label fw-semibold small">
            <i class="fas fa-list me-1"></i>{% trans "Individual Drink Selection" %}
          </label>
          <div class="border rounded p-2" style="max-height: 150px; overflow-y: auto;">
            {% for drink in drinks %}
              <div class="form-check mb-1">
                <input class="form-check-input" type="checkbox" id="drink{{ drink.id }}" name="drinks" value="{{ drink.id }}">
                <label class="form-check-label small" for="drink{{ drink.id }}">
                  <i class="fas fa-glass me-1"></i>{{ drink.name }}
                </label>
              </div>
            {% empty %}
              <p class="text-muted mb-0 small">{% trans "Drink menu will be available during your booking." %}</p>
            {% endfor %}
          </div>
        </div>
      </div>

      <!-- Final Summary -->
      <div class="pricing-card mb-3">
        <p class="fw-bold mb-2 small">
          <i class="fas fa-receipt me-1"></i>{% trans "Final Summary" %}
        </p>
        <div id="finalCostSummary">
          <div class="price-item">
            <span>{% trans "Whole Day Rental" %}</span>
            <span class="fw-semibold">€357.00</span>
          </div>
          <div class="price-item" id="finalDealerCost" style="display: none;">
            <span>{% trans "Professional Dealer" %}</span>
            <span class="fw-semibold">238.00</span>
          </div>
          <div class="price-item" id="finalServiceCost" style="display: none;">
            <span>{% trans "Service Personal" %}</span>
            <span class="fw-semibold">238.00</span>
          </div>
          <div class="price-item" id="finalDrinksCost" style="display: none;">
            <span>{% trans "Drinks Flatrate" %}</span>
            <span class="fw-semibold">238.00</span>
          </div>
          <div class="price-item">
            <span>{% trans "Total Amount" %}</span>
            <span id="finalTotalAmount">€357.00</span>
          </div>
        </div>

        <div class="mt-3 pt-3 border-top">
          <small class="text-muted">
            <i class="fas fa-envelope me-1"></i>
            {% trans "For special requests, email:" %} <strong>mgen@ming-group.de</strong>
          </small>
        </div>
      </div>

      <!-- Terms & Disclaimer Checkbox (NEW) -->
      <div class="mb-3 p-3 border rounded bg-light">
        <div class="form-check">
          <input class="form-check-input" type="checkbox" id="agreeTerms" name="agree_terms" required>
          <label class="form-check-label" for="agreeTerms">
            <span class="fw-semibold small">
              {% trans "I agree to the terms and conditions" %}
            </span>
          </label>
        </div>
        
        <!-- Disclaimer Text (collapsible) -->
        <div class="mt-2">
          <button type="button" class="btn btn-link btn-sm p-0" data-bs-toggle="collapse" data-bs-target="#disclaimerText">
            <i class="fas fa-chevron-down me-1"></i>{% trans "Read Terms" %}
          </button>
          <div class="collapse mt-2" id="disclaimerText">
            <div class="alert alert-warning small" role="alert">
              <p class="fw-semibold mb-2">
                <i class="fas fa-exclamation-triangle me-1"></i>
                {% trans "Notice of Use:" %}
              </p>
              <p class="mb-2">
                {% trans "Der gemietete Pokertisch wird ausschließlich für private Unterhaltungszwecke zur Verfügung gestellt. Jegliches Spiel um Geld ohne gültige Lizenz ist streng verboten. Der Mieter übernimmt die volle Verantwortung dafür, dass keine unerlaubten Glücksspiele stattfinden." %}
              </p>
            </div>
          </div>
        </div>

        <!-- Error message for unchecked checkbox -->
        <div class="error-message text-danger mt-2 small d-none" id="termsError">
          <i class="fas fa-exclamation-circle me-1"></i>
          {% trans "You must agree to the terms to proceed" %}
        </div>
      </div>

      <!-- Payment Section -->
      <!--
      <div class="mb-3">
        <p class="fw-semibold mb-2 small">
          <i class="fas fa-credit-card me-1"></i>{% trans "Payment Information" %}
        </p>
        <div id="paymentMessage" class="mb-2 text-muted small">
          {% trans "Please enter your payment details below to confirm your booking." %}
        </div>
        <div id="dropin-container" class="border rounded p-3" style="min-height: 350px; background: white; width: 100%; max-width: none; margin-bottom: 2rem;"></div>
      </div> -->
<!-- Payment Section (Stripe) -->
<!-- Payment Section (Stripe) -->
<div class="mb-3" style="color: #000 !important;">

  <!-- message goes here (shown after redirect back from Stripe) -->
  <div id="stripePaymentAlert" class="alert d-none small" role="alert"></div>

  <div class="mb-2 small" style="color:#000 !important;">
    {% blocktrans %}
      Pay securely with Stripe. Total amount:
      <strong><span id="stripeAmount">€400.00</span></strong>
    {% endblocktrans %}
  </div>
<div id="bookingSubmitMessage" class="alert d-none mt-3" role="alert"></div>
<button
  type="button"
  id="payWithStripeBtn"
  class="btn btn-primary w-100"
  data-enabled="false"
>
  {% trans "Pay with Stripe" %}
</button>



  <div class="mt-2 small" style="color:#000 !important; opacity:.85;">
    {% trans "You will be redirected to Stripe to complete payment." %}
  </div>
</div>





    </div>
  </div>
</form>

<style>
  .form-step{display:none;padding:0;margin:0}
  .form-step.active{display:block;animation:fadeInStep .3s ease-in-out}
  @keyframes fadeInStep{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
  #dropin-container{position:relative;z-index:1;width:100%!important;max-width:100%!important;min-height:clamp(300px,40vh,400px);padding:var(--space-5);background:#fff;border-radius:.5rem;margin-bottom:var(--space-6)}
  @media (min-width:1280px){#dropin-container{max-width:600px;margin-left:0}}
  #dropin-container .braintree-form,
  #dropin-container .braintree-form__field,
  #dropin-container .braintree-form__label{display:block!important;visibility:visible!important;opacity:1!important;height:auto!important;width:100%!important;max-width:none!important}
  #dropin-container .braintree-dropin{font-family:inherit!important;width:100%!important;max-width:none!important}
  #dropin-container .braintree-form__field{margin-bottom:10px!important}
  #dropin-container .braintree-form__hosted-field{border:2px solid var(--gray-200)!important;border-radius:.5rem!important;padding:.75rem!important;font-size:var(--font-size-base)!important;min-height:44px!important;transition:border-color .2s!important}
  #dropin-container .braintree-form__hosted-field:focus{border-color:var(--theme-red)!important;box-shadow:0 0 0 3px var(--theme-red-light)!important;outline:none!important}
  #dropin-container .braintree-methods-list{width:100%!important}
/* Stripe button should stay visible when disabled */
/* Stripe button styled like Back button (custom, controlled) */
.mgen-nav-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: .35rem;

  width: 100%;
  padding: 0.65rem 1rem;
  border-radius: 12px;           /* same as your theme */
  font-weight: 600;
  font-size: 0.95rem;
  line-height: 1.1;

  background: #1f2937;           /* dark grey like back */
  color: #fff;
  border: 1px solid rgba(255,255,255,0.12);

  transition: transform .12s ease, background .15s ease, border-color .15s ease, opacity .15s ease;
}

.mgen-nav-btn:hover {
  background: #111827;
  border-color: rgba(255,255,255,0.22);
  transform: translateY(-1px);
}

.mgen-nav-btn:active {
  transform: translateY(0px);
}

/* ✅ IMPORTANT: disabled stays visible */
.mgen-nav-btn:disabled,
.mgen-nav-btn[aria-disabled="true"] {
  opacity: 0.55;                 /* visible but inactive */
  cursor: not-allowed;
  filter: grayscale(15%);
  transform: none;
}

/* Stripe button must NEVER disappear */
#payWithStripeBtn {
  display: inline-flex !important;
  visibility: visible !important;
  opacity: 1;
}

/* Disabled state: visible but inactive */
#payWithStripeBtn:disabled,
#payWithStripeBtn[aria-disabled="true"] {
  display: inline-flex !important;
  visibility: visible !important;

  opacity: 0.55;          /* looks disabled */
  cursor: not-allowed;
  pointer-events: none;  /* cannot click */
}

#payWithStripeBtn[data-enabled="false"] {
  cursor: not-allowed;
}

/* Stripe button = Back / Next button look */
#payWithStripeBtn {
  border-radius: 10px;          /* SAME as back button */
  font-weight: 600;
  height: 44px;                 /* matches other nav buttons */
}

/* Logical-disabled Stripe button (still blue) */
#payWithStripeBtn[data-enabled="false"] {
  cursor: not-allowed;
}

/* Optional: tiny visual hint (VERY subtle) */
#payWithStripeBtn[data-enabled="false"]::after {
  content: "";
}

</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // ---- config / globals ----
  const CLOSE_HOUR = 24;
  const MAX_LOOKAHEAD_DAYS = 1; // increase if you want to span more days
  let currentStep = 0;
  const TIMES_OWNER = 'times-v2';
  let timeBuildTicket = 0; // SINGLE-FLIGHT TICKET (global)
   window.bookingTotalAmount = 400;

  // ---- dom refs ----
  const steps = document.querySelectorAll('.form-step');
  const stepIndicators = document.querySelectorAll('.step');
  const nextButtons = document.querySelectorAll('.next-step');
  const prevButtons = document.querySelectorAll('.prev-step');
  const navButtonContainers = document.querySelectorAll('[class^="nav-buttons-step"]');
  const dealerCheckbox = document.getElementById('dealerService');
  const serviceCheckbox = document.getElementById('servicePersonal');
  const drinksCheckbox  = document.getElementById('drinksFlatrate');
  const bookingDateInput = document.getElementById('bookingDate');
  const bookingTimeInput = document.getElementById('bookingTime');
  const bookingDuration  = document.getElementById('bookingDuration');
  const bookingForm = document.getElementById('bookingForm');


  // ---- i18n helper ----
  const _ = (window.gettext || ((s)=>s));

  // ---- time utils ----
  function timeToMinutes(t){ const [H,M]=t.split(':').map(Number); return H*60+(M||0); }
  function minutesToHHMM(mins){ const h=Math.floor(mins/60), m=mins%60; return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; }
  function prevDateISO(dateStr){ const [y,m,d]=dateStr.split('-').map(Number); const dt=new Date(Date.UTC(y,m-1,d)); dt.setUTCDate(dt.getUTCDate()-1); return dt.toISOString().slice(0,10); }
  function addDaysISO(dateStr, days){ const [y,m,d]=dateStr.split('-').map(Number); const dt=new Date(Date.UTC(y,m-1,d)); dt.setUTCDate(dt.getUTCDate()+days); return dt.toISOString().slice(0,10); }

  function showFieldError(inputEl, message) {
  if (!inputEl) return;

  // remove existing message (if any)
  const existing = inputEl.parentNode.querySelector('.error-message');
  if (existing) existing.remove();

  const err = document.createElement('div');
  err.className = 'error-message text-danger mt-1 small';
  err.textContent = message;
  inputEl.parentNode.appendChild(err);

  inputEl.classList.add('is-invalid');
}

function clearFieldError(inputEl) {
  if (!inputEl) return;
  const existing = inputEl.parentNode.querySelector('.error-message');
  if (existing) existing.remove();
  inputEl.classList.remove('is-invalid');
}

  function normalizeUnavailable(list){
    return (list||[]).map(s=>({ start: timeToMinutes(s.start_time), end: timeToMinutes(s.end_time) }));
  }
  function splitOvernightRange(r){
    if (r.end >= r.start) return [r];
    return [ {start:r.start, end:1440}, {start:0, end:r.end} ];
  }
  function mergeRanges(ranges){
    if (!ranges || !ranges.length) return [];
    const sorted = ranges.slice().sort((a,b)=> a.start-b.start || a.end-b.end);
    const out = [ {...sorted[0]} ];
    for (let i=1;i<sorted.length;i++){
      const prev = out[out.length-1], cur = sorted[i];
      if (cur.start <= prev.end) prev.end = Math.max(prev.end, cur.end);
      else out.push({...cur});
    }
    return out;
  }

  async function getMergedUnavailableForDate(dateStr){
    const res = await fetch('/bookings/get_unavailable_slots?date=' + encodeURIComponent(dateStr));
    const data = await res.json();
    return mergeRanges(normalizeUnavailable(data.unavailable_slots));
  }

  // ---- ui helpers ----
  function updateStepIndicators(){
    stepIndicators.forEach((el,idx)=>{
      el.className = (idx < currentStep) ? 'step completed' : (idx === currentStep ? 'step active' : 'step pending');
    });
    navButtonContainers.forEach((c,idx)=> c.style.display = (idx===currentStep?'block':'none'));
  }

function updatePricing() {
  const VAT = 0.19;

  // Boss pricing (NET)
const NET_DAY = 300;
const NET_DEALER = 200;
const NET_SERVICE = 200;   // ✅ add
const NET_DRINKS = 200;

  // Only these are relevant for boss logic:
const dealerOn = dealerCheckbox?.checked;
const serviceOn = serviceCheckbox?.checked;  // ✅ add
const drinksOn = drinksCheckbox?.checked;

let netTotal = NET_DAY;
if (dealerOn) netTotal += NET_DEALER;
if (serviceOn) netTotal += NET_SERVICE;   // ✅ add
if (drinksOn) netTotal += NET_DRINKS;

  const grossTotal = netTotal * (1 + VAT);

  // Show/hide rows (you already have these IDs)
  const finalDealerCost = document.getElementById("finalDealerCost");
  if (finalDealerCost) finalDealerCost.style.display = dealerOn ? "flex" : "none";

  const finalDrinksCost = document.getElementById("finalDrinksCost");
  if (finalDrinksCost) finalDrinksCost.style.display = drinksOn ? "flex" : "none";

  const finalServiceCost = document.getElementById("finalServiceCost");
  if (finalServiceCost) finalServiceCost.style.display = serviceOn ? "flex" : "none";

  // Expose total to Stripe button
  window.bookingTotalAmount = grossTotal;

  // Update the UI totals
  document.getElementById("stripeAmount").textContent = `€${grossTotal.toFixed(2)}`;
  document.getElementById("finalTotalAmount").textContent = `€${grossTotal.toFixed(2)}`;

  // If you also update totalAmount somewhere else:
  const totalAmountEl = document.getElementById("totalAmount");
  if (totalAmountEl) totalAmountEl.textContent = `€${grossTotal.toFixed(2)}`;
}

  function showStep(idx){
    steps.forEach((s,i)=>{ if(i!==idx) s.classList.remove('active'); });
    setTimeout(()=>{
      steps[idx].classList.add('active');
      //if (idx===2 && window.initializeBraintreeOnStep3) window.initializeBraintreeOnStep3();
    },50);
    updateStepIndicators();
  }

async function validateStep(stepIdx){
    const step = steps[stepIdx];
    const inputs = step.querySelectorAll('input:not([type="hidden"]):not([type="checkbox"]), select');
    let ok = true;
    inputs.forEach(input=>{
      const msg = input.parentNode.querySelector('.error-message');
      if (input.hasAttribute('required') && !String(input.value||'').trim()){
        ok=false;
        if(!msg){
          const err = document.createElement('div');
          err.className='error-message text-danger mt-1 small';
          err.textContent='This field is required.';
          input.parentNode.appendChild(err);
        }
        input.classList.add('is-invalid');
      } else {
        msg && msg.remove();
        input.classList.remove('is-invalid');
      }
    });
    // ⬇️ ADD THIS BLOCK
  // ✅ Step 2: Number of people must be 1–50
if (stepIdx === 1) {
  const peopleInput = document.getElementById("numberOfPeople");
  const val = parseInt(peopleInput?.value, 10);

  if (!peopleInput?.value || Number.isNaN(val)) {
    ok = false;
    showFieldError(peopleInput, _("Please enter number of people."));
  } else if (val < 1) {
    ok = false;
    showFieldError(peopleInput, _("Minimum is 1 person."));
  } else if (val > 50) {
    ok = false;
    showFieldError(peopleInput, _("Maximum capacity is 50 people."));
  } else {
    clearFieldError(peopleInput);
  }
}

    if (stepIdx === 0 && window.dateAtSixUnavailable) {
    return false;
  }
    // NEW: Check terms checkbox on step 3 (payment step) - stepIdx === 2
    if (stepIdx === 2) {
      const termsCheckbox = document.getElementById('agreeTerms');
      const termsError = document.getElementById('termsError');
      
      if (termsCheckbox && !termsCheckbox.checked) {
        ok = false;
        termsError.classList.remove('d-none');
        termsCheckbox.classList.add('is-invalid');
      } else if (termsCheckbox) {
        termsError.classList.add('d-none');
        termsCheckbox.classList.remove('is-invalid');
      }
    }

    if (stepIdx===0 && ok){
      // ...existing step 0 validation code...
    }
    return ok;
}
async function rebuildTimeDropdownForDate(dateStr){
  const myTicket = ++timeBuildTicket;                // single-flight
  const stillMine = () => myTicket === timeBuildTicket;

  const tSel = bookingTimeInput;
  const dSel = bookingDuration;
  const _ = (window.gettext || (s=>s));

  // reset start-time select
  tSel.innerHTML = '';
  const ph = document.createElement('option');
  ph.value = ''; ph.disabled = true; ph.selected = true;
  ph.textContent = _('Select Time');
  ph.dataset.owner = TIMES_OWNER;
  tSel.appendChild(ph);

  // --- lock to prevent other scripts from repopulating ---
  let lockActive = true;
  const snapshotHTML = () => tSel.innerHTML;
  let lastGood = snapshotHTML();

  const mo = new MutationObserver(() => {
    if (!lockActive) return;
    // if anything not owned by us shows up, revert
    const onlyOurs = Array.from(tSel.options).every(o => o.dataset.owner === TIMES_OWNER);
    if (!onlyOurs) tSel.innerHTML = lastGood;
  });
  mo.observe(tSel, {childList: true, subtree: true});
  // -------------------------------------------------------

  try {
    // today
    const todayRes = await fetch('/bookings/get_unavailable_slots?date=' + encodeURIComponent(dateStr));
    if (!stillMine()) return;
    const todayData = await todayRes.json();
    if (!stillMine()) return;
    let todayRanges = normalizeUnavailable(todayData.unavailable_slots);

    // carry from yesterday (overnight segments)
    try {
      const yday = prevDateISO(dateStr);
      const yRes = await fetch('/bookings/get_unavailable_slots?date=' + encodeURIComponent(yday));
      if (!stillMine()) return;
      const yData = await yRes.json();
      if (!stillMine()) return;
    const yRanges = normalizeUnavailable(yData.unavailable_slots);
    for (const r of yRanges) {
      // only if it actually wraps past midnight (end < start)
      if (r.end < r.start) {
        const parts = splitOvernightRange(r); // [ {start..1440}, {0..end} ]
        // carry only the second part (00:00..end) into today
        if (parts[1] && parts[1].end > 0) {
          todayRanges.push(parts[1]);
        }
      }
    }

    } catch(e) { console.warn('prev-day fetch failed:', e); }

    // split+clip overnight, clean, merge, dedupe
    const flat = [];
    for (const r of todayRanges){
      for (const p of splitOvernightRange(r)){
        if (p.end > 0 && p.start < 1440){
          flat.push({start: Math.max(0,p.start), end: Math.min(1440,p.end)});
        }
      }
    }
const cleaned = flat
  .filter(r => r.end > r.start)               // drop zero/negative
  .map(r => ({
    start: Math.max(0, Math.min(1440, r.start)),
    end:   Math.max(0, Math.min(1440, r.end))
  }))
  .sort((a,b) => a.start - b.start || a.end - b.end);

    let dayUnavailable = mergeRanges(cleaned);
console.log('[dayUnavailable]',
  dayUnavailable.map(r => `${minutesToHHMM(r.start)}-${minutesToHHMM(r.end)}`));

    const seen = new Set();
    dayUnavailable = dayUnavailable.filter(r=>{
      const key = r.start + ':' + r.end;
      if (seen.has(key)) return false;
      seen.add(key); return true;
    });

    // render, keeping order
    const openMin = 0, closeMin = CLOSE_HOUR * 60;
    let cursor = openMin, i = 0;

    while (cursor < closeMin){
      const block = dayUnavailable[i];

      if (block && block.start <= cursor && cursor < block.end){
        // inside booked block -> one disabled line
  const bookedStart = block.start;
  const bookedEnd = Math.min(block.end, closeMin);
        const label = `${minutesToHHMM(bookedStart)} ${_('to')} ${minutesToHHMM(bookedEnd)} (${_('Booked')})`;

        const opt = document.createElement('option');
        opt.value = ''; opt.disabled = true; opt.textContent = label;
        opt.dataset.owner = TIMES_OWNER;
        tSel.appendChild(opt);

  cursor = Math.ceil(bookedEnd / 60) * 60;
  if (cursor >= block.end) i++;
  continue;
      }

      if (block && cursor < block.start){
        // free hours until next block
        while (cursor < Math.min(block.start, closeMin)){
          const opt = document.createElement('option');
          opt.value = minutesToHHMM(cursor);

          opt.textContent = minutesToHHMM(cursor);
          opt.dataset.owner = TIMES_OWNER;
          tSel.appendChild(opt);
          cursor += 60;
        }
        continue;
      }

      if (!block){
        // no more blocks today -> free to close
        while (cursor < closeMin){
          const opt = document.createElement('option');
          opt.value = minutesToHHMM(cursor);
          opt.textContent = minutesToHHMM(cursor);
          opt.dataset.owner = TIMES_OWNER;
          tSel.appendChild(opt);
          cursor += 60;
        }
      }
    }

    lastGood = snapshotHTML(); // freeze our good state
  } catch(e){
    console.error('rebuildTimeDropdownForDate error:', e);
  } finally {
    // let our list "win" for ~1s, then unlock
    setTimeout(()=>{ lockActive = false; mo.disconnect(); }, 1000);
  }

  // reset durations placeholder
  if (dSel) {
    dSel.innerHTML = '';
  const dph = document.createElement('option');
  dph.value=''; dph.disabled=true; dph.selected=true;
  dph.textContent = _('Select Time First');
  dph.dataset.owner = TIMES_OWNER;
  dSel.appendChild(dph);
  }
}


  // ---- durations builder (with next-day look-ahead) ----
  if (!bookingTimeInput.dataset.boundDur){
    bookingTimeInput.dataset.boundDur='1';
    bookingTimeInput.addEventListener('change', async () => {
      const dateVal = bookingDateInput?.value;
      const timeVal = bookingTimeInput?.value;
      if (!dateVal || !timeVal) return;

      const em = bookingDateInput.parentNode.querySelector('.availability-error');
      em && em.remove();
      bookingTimeInput.classList.remove('is-invalid');

      function buildDurationOptions(maxHours, messageIfNone){
        bookingDuration.innerHTML='';
        const ph = document.createElement('option');
        ph.value=''; ph.disabled=true; ph.selected=true; ph.dataset.owner='durations-v2';
        ph.textContent = _('Select hours');
        bookingDuration.appendChild(ph);

        if (maxHours<=0){
          const o = document.createElement('option');
          o.value=''; o.disabled=true; o.dataset.owner='durations-v2';
          o.textContent = messageIfNone || _('No duration available from this start time');
          bookingDuration.appendChild(o);
          return;
        }
        for (let h=1; h<=maxHours; h++){
          const o = document.createElement('option');
          o.value=String(h); o.textContent=String(h); o.dataset.owner='durations-v2';
          bookingDuration.appendChild(o);
        }
      }

      buildDurationOptions(0, _('Loading…'));

      try{
        const resp = await fetch('/bookings/get_unavailable_slots?date=' + encodeURIComponent(dateVal));
        const data = await resp.json();
        const merged = mergeRanges(normalizeUnavailable(data.unavailable_slots));

        const startHHMM = timeVal.slice(0,5);
        const [H,M] = startHHMM.split(':').map(Number);
        const selectedStartMin = H*60 + (M||0);
        const dayCloseMin = CLOSE_HOUR*60;

        // inside a block → none
        const inside = merged.some(b => selectedStartMin >= b.start && selectedStartMin < b.end);
        if (inside){ buildDurationOptions(0); return; }

        // next same-day block
        let nextBlockStart = dayCloseMin;
        for (const b of merged){ if (b.start >= selectedStartMin){ nextBlockStart = b.start; break; } }

        let freeUntilNext = nextBlockStart - selectedStartMin;

        // look ahead into following days (up to MAX_LOOKAHEAD_DAYS)
        if (nextBlockStart === dayCloseMin){
          for (let off=1; off<=MAX_LOOKAHEAD_DAYS; off++){
            const probe = addDaysISO(dateVal, off);
            const nextDayMerged = await getMergedUnavailableForDate(probe);
            if (nextDayMerged.length){
              freeUntilNext += (off-1)*dayCloseMin;   // full free days between
              freeUntilNext += nextDayMerged[0].start; // free until earliest busy next day
              break;
            }
            freeUntilNext += dayCloseMin; // whole day free
          }
        }

        const maxHours = Math.max(0, Math.floor(freeUntilNext/60));
        buildDurationOptions(maxHours);

      }catch(e){
        console.error('[durations] build error', e);
        buildDurationOptions(0, _('Unable to load durations'));
      }
    });
  }

  // ---- wire up rest of UI ----
  dealerCheckbox?.addEventListener('change', updatePricing);
  serviceCheckbox?.addEventListener('change', updatePricing);
  drinksCheckbox?.addEventListener('change', updatePricing);

  nextButtons.forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      btn.disabled=true; const prevHTML=btn.innerHTML;
      btn.innerHTML='<i class="fas fa-spinner fa-spin me-1"></i>Checking...';
      try{
        if (await validateStep(currentStep)){
          if (currentStep < steps.length-1){ currentStep++; showStep(currentStep); updatePricing(); }
        }
      } finally {
        btn.disabled=false; btn.innerHTML=prevHTML;
      }
    });
  });

  prevButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if (currentStep>0){ currentStep--; showStep(currentStep); }
    });
  });

  if (bookingDateInput){
    bookingDateInput.addEventListener('change', async ()=>{
      const err = bookingDateInput.parentNode.querySelector('.availability-error');
      err && err.remove();
      bookingDateInput.classList.remove('is-invalid');
      bookingTimeInput?.classList.remove('is-invalid');

      if (!bookingDateInput.value) return;
      try { await rebuildTimeDropdownForDate(bookingDateInput.value);
        Array.from(bookingTimeInput.options).forEach(o=>{
          if (o.dataset.owner !== TIMES_OWNER) o.remove();
        });
      }
      catch(e){ console.error('Failed to rebuild time dropdown:', e); }
    });
  }

  // init
if (bookingForm) {
  bookingForm.addEventListener('submit', function (e) {
    const termsCheckbox = document.getElementById('agreeTerms');
    const termsError = document.getElementById('termsError');

    if (!termsCheckbox || !termsCheckbox.checked) {
      e.preventDefault(); // block the booking
      termsError.classList.remove('d-none');
      termsCheckbox.classList.add('is-invalid');
      termsCheckbox.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  });
}

  function forceFixedSlot() {
    if (bookingTimeInput) {
      bookingTimeInput.innerHTML = '';
      const tOpt = document.createElement('option');
      tOpt.value = '18:00';
      tOpt.textContent = '18:00';
      tOpt.selected = true;
      bookingTimeInput.appendChild(tOpt);
      bookingTimeInput.value = '18:00';
    }

    if (bookingDuration) {
      bookingDuration.innerHTML = '';
      const dOpt = document.createElement('option');
      dOpt.value = '18';
      dOpt.textContent = '18';
      dOpt.selected = true;
      bookingDuration.appendChild(dOpt);
      bookingDuration.value = '18';
    }
  }

  // Run once on load
  forceFixedSlot();

  // Run again whenever date changes (after any other listeners)
  if (bookingDateInput) {
    bookingDateInput.addEventListener('change', () => {
      forceFixedSlot();
    });
  }
  showStep(currentStep);
  updatePricing();
  updateStepIndicators();

const stripePayBtn = document.getElementById("payWithStripeBtn");
const termsCheckbox = document.getElementById("agreeTerms");

function syncStripeButtonState() {
  if (!termsCheckbox || !stripePayBtn) return;

  const ok = termsCheckbox.checked;
  stripePayBtn.dataset.enabled = ok ? "true" : "false";

}



// ---- Move Stripe button into sticky nav (Step 3) ----
(function moveStripeButtonToNav() {
  const btn = document.getElementById("payWithStripeBtn");
  const navSlot = document.getElementById("stripePayNavSlot");
  const inlineWrap = document.getElementById("stripePayInlineWrap");

  if (!btn || !navSlot) return;

  // Make it fit nicely next to Back
  btn.classList.remove("w-100");
  btn.classList.add("w-100"); // keep full width inside its col-6

  // Move the wrapper (keeps layout clean)
  if (inlineWrap) {
    navSlot.appendChild(inlineWrap);
  } else {
    navSlot.appendChild(btn);
  }
})();

// Initial state
syncStripeButtonState();

// React on checkbox change
termsCheckbox.addEventListener("change", () => {
  document.getElementById("termsError")?.classList.add("d-none");
  termsCheckbox.classList.remove("is-invalid");
  syncStripeButtonState();
});

const stripeAlert = document.getElementById("stripePaymentAlert");

function showStripeAlert(type, text) {
  if (!stripeAlert) return;
  stripeAlert.className = `alert alert-${type} small`; // bootstrap
  stripeAlert.textContent = text;
  stripeAlert.classList.remove("d-none");
}

async function startStripeCheckout() {
  const amountEuro = window.bookingTotalAmount || 400;
  const amountCents = Math.round(amountEuro * 100);
  window.user_id = "{{ request.session.user_id|default:'' }}";
  const user_id = "{{ request.session.user_id|default:'' }}";
  const resp = await fetch("/payments/create-checkout-session/", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-CSRFToken": "{{ csrf_token }}",
    },
    body: JSON.stringify({
      currency: "eur",
      booking_date: document.getElementById("bookingDate")?.value,
      booking_time: "18:00",
      number_of_people: document.getElementById("numberOfPeople")?.value,
      number_of_hours: 18,
      user_id: user_id,
      dealer: document.getElementById("dealerService")?.checked || false,
      service: document.getElementById("servicePersonal")?.checked || false,
      drinks_flatrate: document.getElementById("drinksFlatrate")?.checked || false,
    }),
  });

  // If you ever see: Unexpected token '<' ... it means backend returned HTML (500/403 page)
  const data = await resp.json();

  if (!resp.ok || !data.url) {
    throw new Error(data.error || "Could not start Stripe Checkout.");
  }

  window.location.href = data.url;
}

if (stripePayBtn) {
  stripePayBtn.addEventListener("click", async () => {
    if (stripePayBtn.dataset.enabled !== "true") {
      document.getElementById("termsError")?.classList.remove("d-none");
      document.getElementById("agreeTerms")?.scrollIntoView({
        behavior: "smooth",
        block: "center"
      });
      return;
    }

    try {
      await startStripeCheckout();
    } catch (err) {
      showStripeAlert("danger", err.message || String(err));
    }
  });
}


});
</script>
