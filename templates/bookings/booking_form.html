{% load i18n %}

<form id="bookingForm" method="POST" novalidate>
  {% csrf_token %}
  <button type="button" id="bookingBackArrow" class="booking-back-arrow" aria-label="Go back">
    ‚Üê Back
  </button>
  <!-- Step 1: Booking Date and Time -->
  <div class="form-step active" data-step="1">

    <div class="mb-3">
      <p class="fw-bold text-dark mb-2 small">
        <i class="fas fa-calendar-day text-danger me-1"></i>
        {% trans "Select Your Day" %}
      </p>

      <div class="mb-2">
        <label for="bookingDate" class="form-label fw-semibold small">
          <i class="fas fa-calendar-alt me-1"></i>{% trans "Booking Date" %}
        </label>
        <input type="date" class="form-control" id="bookingDate" name="booking_date" required />
        <div id="dateAvailabilityMessage" class="small mt-1"></div>
      </div>

      <div class="row">
<div class="col-md-6 mb-3">
  <label class="form-label fw-semibold small">
    <i class="fas fa-clock me-1"></i>{% trans "Start Time" %}
  </label>

  <p class="form-text text-muted small mb-1">
    <i class="fas fa-info-circle me-1"></i>
    {% trans "Start time is fixed: 18:00 ‚Äì 12:00 the next day." %}
  </p>

  <!-- Hidden select, always 18:00 -->
  <select class="form-select d-none" id="bookingTime" name="booking_time">
    <option value="18:00" selected>18:00</option>
  </select>

  <!-- Optional: keep but hide the old message -->
  <div class="form-text text-muted mt-1 small d-none" id="timeSlotMessage">
    <i class="fas fa-info-circle me-1"></i>
    {% trans "Available start times based on MGEN-F24 calendar" %}
  </div>
</div>


<div class="col-md-6 mb-3">
  <label class="form-label fw-semibold small">
    <i class="fas fa-hourglass-half me-1"></i>{% trans "Duration" %}
  </label>

  <!-- Keep the select for JS/backend, but hide it and prefill with 18 -->
  <select class="form-select d-none" id="bookingDuration" name="number_of_hours">
    <option value="18" selected>18</option>
  </select>

  <!-- Optional: you can remove this if you don't need it anymore -->
  <div class="form-text text-muted mt-1 small d-none" id="durationMessage">
    <i class="fas fa-info-circle me-1"></i>
    {% trans "Available hours based on selected time" %}
  </div>
</div>

      </div>
    </div>
  </div>

  <!-- Step 2: Number of People and Services -->
  <div class="form-step" data-step="2">
    <div class="mb-3">
      <p class="fw-bold text-dark mb-2 small">
        <i class="fas fa-users text-danger me-1"></i>
        {% trans "People & Services" %}
      </p>

      <div class="mb-3">
        <label for="numberOfPeople" class="form-label fw-semibold small">
          <i class="fas fa-user-friends me-1"></i>{% trans "Number of People" %}
        </label>
        <input type="number" class="form-control" id="numberOfPeople" name="number_of_people" min="1" max="50" required />
        <div class="form-text text-muted small">
          {% trans "Maximum capacity: 50 people" %}
        </div>
      </div>

      <div class="mb-3">
        <label class="form-label fw-semibold small mb-2">
          <i class="fas fa-concierge-bell me-1"></i>{% trans "Additional Services" %}
        </label>
        <div class="row g-2">
          <div class="col-12">
            <div class="form-check p-2 border rounded">
              <input class="form-check-input" type="checkbox" id="dealerService" name="services" value="dealer">
              <label class="form-check-label fw-semibold small" for="dealerService">
                <i class="fas fa-user-tie me-1"></i>{% trans "Professional Dealer" %}
                <div class="text-muted small">{% trans "+‚Ç¨" %}{{ pricing_cfg.gross_dealer }}
{% trans " - Expert poker dealer for your session" %}</div>
              </label>
            </div>
          </div>
          <div class="col-12">
            <div class="form-check p-2 border rounded">
              <input class="form-check-input" type="checkbox" id="servicePersonal" name="services" value="service">
              <label class="form-check-label fw-semibold small" for="servicePersonal">
                <i class="fas fa-user-cog me-1"></i>{% trans "Service Personal" %}
                <div class="text-muted small">{% trans "+‚Ç¨" %}{{ pricing_cfg.gross_service }}{% trans " - Dedicated service staff for your event" %}</div>
              </label>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Step 3: Drinks and Payment -->
  <div class="form-step" data-step="3">
    <div class="mb-3">
      <p class="fw-bold text-dark mb-2 small">
        <i class="fas fa-cocktail text-danger me-1"></i>
        {% trans "Drinks & Payment" %}
      </p>

      <div class="mb-3">
        <label class="form-label fw-semibold small mb-2">
          <i class="fas fa-glass-cheers me-1"></i>{% trans "Beverage Options" %}
        </label>
        <div class="mb-3">
          <div class="form-check p-2 border rounded">
            <input class="form-check-input" type="checkbox" id="drinksFlatrate" name="drinks_flatrate" value="flatrate">
            <label class="form-check-label fw-semibold small" for="drinksFlatrate">
              <i class="fas fa-wine-bottle me-1"></i>{% trans "Drinks Flatrate" %}
              <div class="text-muted small">{% trans "+‚Ç¨" %}{{ pricing_cfg.gross_drinks_flatrate }}{% trans " - Unlimited beverages for your group" %}</div>
            </label>
          </div>
        </div>

        <div class="alert alert-info">
          <i class="fas fa-info-circle me-2"></i>
          <strong>{% trans "Individual Drinks:" %}</strong> {% trans "Available for purchase separately during your event" %}
        </div>

        <div class="mb-3">
          <label class="form-label fw-semibold small">
            <i class="fas fa-list me-1"></i>{% trans "Individual Drink Selection" %}
          </label>
          <div class="border rounded p-2" style="max-height: 150px; overflow-y: auto;">
            {% for drink in drinks %}
              <div class="form-check mb-1">
                <input class="form-check-input" type="checkbox" id="drink{{ drink.id }}" name="drinks" value="{{ drink.id }}">
                <label class="form-check-label small" for="drink{{ drink.id }}">
                  <i class="fas fa-glass me-1"></i>{{ drink.name }}
                </label>
              </div>
            {% empty %}
            {% endfor %}
          </div>
        </div>
      </div>

      <!-- Final Summary -->
      <div class="pricing-card mb-3">
        <p class="fw-bold mb-2 small">
          <i class="fas fa-receipt me-1"></i>{% trans "Final Summary" %}
        </p>
        <div id="finalCostSummary">
          <div class="price-item">
            <span>{% trans "Whole Day Rental" %}</span>
            <span class="fw-semibold">‚Ç¨{{ pricing_cfg.gross_day_rental }}</span>
          </div>
          <div class="price-item" id="finalDealerCost" style="display: none;">
            <span>{% trans "Professional Dealer" %}</span>
            <span class="fw-semibold">‚Ç¨{{ pricing_cfg.gross_dealer }}</span>
          </div>
          <div class="price-item" id="finalServiceCost" style="display: none;">
            <span>{% trans "Service Personal" %}</span>
            <span class="fw-semibold">‚Ç¨{{ pricing_cfg.gross_service }}</span>
          </div>
          <div class="price-item" id="finalDrinksCost" style="display: none;">
            <span>{% trans "Drinks Flatrate" %}</span>
            <span class="fw-semibold">‚Ç¨{{ pricing_cfg.gross_drinks_flatrate }}</span>
          </div>

<!-- Promo Code row (no button, compact input aligned like amounts) -->
<div class="price-item align-items-center">
  <span class="fw-semibold">Promo Code</span>

  <div class="ms-auto d-flex align-items-center" style="gap:10px;">
<input
  type="text"
  id="promoCodeInput"
  placeholder="ENTER"
  autocomplete="off"
  spellcheck="false"
  class="promo-underline-input text-end"
  style="
    width: 120px;
    height: 28px;
    border: none;
    border-bottom: 1.5px solid #cfd4da;
    border-radius: 0;
    padding: 2px 0;
    background: transparent;
    font-weight: 600;
    letter-spacing: .12em;
    outline: none;
    box-shadow: none;
  "
/>

  </div>
</div>

<div id="promoMsg" class="promo-hint"></div>

<div id="finalDiscountRow" class="price-item discount" style="display:none;">
  <span>Discount</span>
  <span id="finalDiscountAmount" class="amount">-‚Ç¨0.00</span>
</div>


<input type="hidden" name="promo_code" id="promoCodeHidden" value="">
<input type="hidden" name="promo_discount_gross" id="promoDiscountHidden" value="0">


<div class="price-item">
  <span class="fw-bold">Total</span>
  <span class="fw-bold" id="finalTotalAmount">‚Ç¨0.00</span>
</div>

<div class="fw-bold small text-muted mt-1 mb-2">
  A ‚Ç¨{{ pricing_cfg.deposit_amount }} security deposit is required and will be refunded after the event, once the venue and equipment are checked.
</div>


        </div>

        <div class="mt-3 pt-3 border-top">
          <small class="text-muted">
            <i class="fas fa-envelope me-1"></i>
            {% trans "For special requests, email:" %} <strong>mgen@ming-group.de</strong>
          </small>
        </div>
      </div>

      <!-- Terms & Disclaimer Checkbox (NEW) -->
      <div class="mb-3 p-3 border rounded bg-light">
        <div class="form-check">
          <input class="form-check-input" type="checkbox" id="agreeTerms" name="agree_terms" required>
          <label class="form-check-label" for="agreeTerms">
            <span class="fw-semibold small">
              {% trans "I agree to the terms and conditions" %}
            </span>
          </label>
        </div>
        
        <!-- Disclaimer Text (collapsible) -->
        <div class="mt-2">
          <button type="button" class="btn btn-link btn-sm p-0" data-bs-toggle="collapse" data-bs-target="#disclaimerText">
            <i class="fas fa-chevron-down me-1"></i>{% trans "Read Terms" %}
          </button>
          <div class="collapse mt-2" id="disclaimerText">
            <div class="alert alert-warning small" role="alert">
              <p class="fw-semibold mb-2">
                <i class="fas fa-exclamation-triangle me-1"></i>
                {% trans "Notice of Use:" %}
              </p>
              <p class="mb-2">
                {% trans "Der gemietete Pokertisch wird ausschlie√ülich f√ºr private Unterhaltungszwecke zur Verf√ºgung gestellt. Jegliches Spiel um Geld ohne g√ºltige Lizenz ist streng verboten. Der Mieter √ºbernimmt die volle Verantwortung daf√ºr, dass keine unerlaubten Gl√ºcksspiele stattfinden." %}
              </p>
            </div>
          </div>
        </div>

        <!-- Error message for unchecked checkbox -->
        <div class="error-message text-danger mt-2 small d-none" id="termsError">
          <i class="fas fa-exclamation-circle me-1"></i>
          {% trans "You must agree to the terms to proceed" %}
        </div>
      </div>

      <!-- Payment Section -->
      <!--
      <div class="mb-3">
        <p class="fw-semibold mb-2 small">
          <i class="fas fa-credit-card me-1"></i>{% trans "Payment Information" %}
        </p>
        <div id="paymentMessage" class="mb-2 text-muted small">
          {% trans "Please enter your payment details below to confirm your booking." %}
        </div>
        <div id="dropin-container" class="border rounded p-3" style="min-height: 350px; background: white; width: 100%; max-width: none; margin-bottom: 2rem;"></div>
      </div> -->
<!-- Payment Section (Stripe) -->
<!-- Payment Section (Stripe) -->
<div class="mb-3" style="color: #000 !important;">

  <!-- message goes here (shown after redirect back from Stripe) -->
  <div id="stripePaymentAlert" class="alert d-none small" role="alert"></div>

<div id="bookingSubmitMessage" class="alert d-none mt-3" role="alert"></div>
<button
  type="button"
  id="payWithStripeBtn"
  class="btn btn-secondary-custom w-100"
  data-enabled="false"
>
        <i class="fas fa-money-bill-wave me-1"></i>
        Pay with Stripe
</button>


<div id="cashInfo" class="small text-danger mt-2 fw-semibold"></div>

</div>





    </div>
  </div>
<!-- Fullscreen Loader -->
<div id="fullScreenLoader" class="mgen-loader d-none" aria-hidden="true">
  <div class="mgen-loader-card">
    <div class="spinner-border" role="status" aria-hidden="true"></div>
    <div class="mt-2 fw-semibold">Processing‚Ä¶</div>
    <div class="small text-muted">Please don‚Äôt close this page.</div>
  </div>
</div>

</form>

<style>

  .mgen-loader {
  position: fixed;
  inset: 0;
  background: rgba(255,255,255,0.75);
  backdrop-filter: blur(6px);
  z-index: 999999;
  display: flex;
  align-items: center;
  justify-content: center;
}

.mgen-loader-card {
  background: #fff;
  border-radius: 16px;
  padding: 18px 22px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.12);
  text-align: center;
  min-width: 220px;
}

.form-step {
  display: none;
  padding: 0;
  margin: 0;
  position: relative; /* üî• THIS IS THE FIX */
}

  .form-step.active{display:block;animation:fadeInStep .3s ease-in-out}
  @keyframes fadeInStep{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
  #dropin-container{position:relative;z-index:1;width:100%!important;max-width:100%!important;min-height:clamp(300px,40vh,400px);padding:var(--space-5);background:#fff;border-radius:.5rem;margin-bottom:var(--space-6)}
  @media (min-width:1280px){#dropin-container{max-width:600px;margin-left:0}}
  #dropin-container .braintree-form,
  #dropin-container .braintree-form__field,
  #dropin-container .braintree-form__label{display:block!important;visibility:visible!important;opacity:1!important;height:auto!important;width:100%!important;max-width:none!important}
  #dropin-container .braintree-dropin{font-family:inherit!important;width:100%!important;max-width:none!important}
  #dropin-container .braintree-form__field{margin-bottom:10px!important}
  #dropin-container .braintree-form__hosted-field{border:2px solid var(--gray-200)!important;border-radius:.5rem!important;padding:.75rem!important;font-size:var(--font-size-base)!important;min-height:44px!important;transition:border-color .2s!important}
  #dropin-container .braintree-form__hosted-field:focus{border-color:var(--theme-red)!important;box-shadow:0 0 0 3px var(--theme-red-light)!important;outline:none!important}
  #dropin-container .braintree-methods-list{width:100%!important}
/* Stripe button should stay visible when disabled */
/* Stripe button styled like Back button (custom, controlled) */
.mgen-nav-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: .35rem;

  width: 100%;
  padding: 0.65rem 1rem;
  border-radius: 12px;           /* same as your theme */
  font-weight: 600;
  font-size: 0.95rem;
  line-height: 1.1;

  background: #1f2937;           /* dark grey like back */
  color: #fff;
  border: 1px solid rgba(255,255,255,0.12);

  transition: transform .12s ease, background .15s ease, border-color .15s ease, opacity .15s ease;
}

.mgen-nav-btn:hover {
  background: #111827;
  border-color: rgba(255,255,255,0.22);
  transform: translateY(-1px);
}

.mgen-nav-btn:active {
  transform: translateY(0px);
}

/* ‚úÖ IMPORTANT: disabled stays visible */
.mgen-nav-btn:disabled,
.mgen-nav-btn[aria-disabled="true"] {
  opacity: 0.55;                 /* visible but inactive */
  cursor: not-allowed;
  filter: grayscale(15%);
  transform: none;
}

/* Stripe button must NEVER disappear */
#payWithStripeBtn {
  display: inline-flex !important;
  visibility: visible !important;
  opacity: 1;
}

/* Disabled state: visible but inactive */
#payWithStripeBtn:disabled,
#payWithStripeBtn[aria-disabled="true"] {
  display: inline-flex !important;
  visibility: visible !important;

  opacity: 0.55;          /* looks disabled */
  cursor: not-allowed;
  pointer-events: none;  /* cannot click */
}

#payWithStripeBtn[data-enabled="false"] {
  cursor: not-allowed;
}

/* Stripe button = Back / Next button look */
#payWithStripeBtn {
  height: 44px;
  border-radius: 20px;
  font-weight: 600;

  background: transparent;
  color: #635BFF;              /* Stripe blue */
  border: 2px solid #635BFF;

  transition: all 0.15s ease;
}

#payWithStripeBtn:hover:not(:disabled) {
  background: #635BFF;
  color: #ffffff;
}

#payWithCashBtn {
  height: 44px;
  border-radius: 20px;
  font-weight: 600;

  background: #ffffff;
  color: #111827;
  border: 2px solid #111827;

  transition: all 0.15s ease;
}

#payWithCashBtn:hover:not(:disabled) {
  background: #111827;
  color: #ffffff;
}

#payWithStripeBtn:disabled,
#payWithCashBtn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}



/* Logical-disabled Stripe button (still blue) */
#payWithStripeBtn[data-enabled="false"] {
  cursor: not-allowed;
}

/* Optional: tiny visual hint (VERY subtle) */
#payWithStripeBtn[data-enabled="false"]::after {
  content: "";
}

/* Make sure arrow is above everything */
.booking-back-arrow{
  position: fixed;              /* IMPORTANT: fixed, not absolute */
  top: 92px;                    /* adjust this */
  left: 40px;                   /* adjust this */
  z-index: 999999;              /* higher than navbar */
  display: inline-flex;
  gap: 6px;

  background: rgba(255,255,255,0.92);
  color: #1f2937;
  font-weight: 600;
  font-size: 14px;

  border-radius: 999px;
  padding: 6px 10px;

  box-shadow: 0 2px 10px rgba(0,0,0,0.14);
  cursor: pointer;
}


.booking-back-arrow:hover {
  background: rgba(47, 111, 237, 0.08);
}

#bookingForm{
  position: relative;   /* IMPORTANT */
}

.promo-underline-input {
  transition: border-color 0.2s ease;
}

.promo-underline-input:focus {
  border-bottom-color: #0d6efd; /* Bootstrap primary blue */
}

.promo-underline-input::placeholder {
  letter-spacing: .08em;
  opacity: 0.6;
}

/* Promo helper / validation message */
.promo-hint {
  margin-top: 6px;
  font-size: 13px;
  line-height: 1.35;
  font-weight: 500;
  color: #c0392b; /* muted red */
  font-family: inherit;
}

/* Optional: softer variant if you want */
.promo-hint.warning {
  color: #b54708; /* amber-ish */
}

.promo-hint.hidden {
  display: none;
}
.promo-hint.success {
  color: #1e8e3e;
  font-weight: 600;
}

/* Discount row when promo is applied */
.price-item.discount {
  color: #1e8e3e;        /* same green as promo success */
  font-weight: 600;
}

.price-item.discount .amount {
  color: #1e8e3e;
}

</style>

<script>
document.addEventListener('DOMContentLoaded', () => {

  const loaderEl = document.getElementById("fullScreenLoader");

function showLoader() {
  if (!loaderEl) return;
  loaderEl.classList.remove("d-none");
  loaderEl.setAttribute("aria-hidden", "false");
}

function hideLoader() {
  if (!loaderEl) return;
  loaderEl.classList.add("d-none");
  loaderEl.setAttribute("aria-hidden", "true");
}

function setBtnLoading(btn, loadingText) {
  if (!btn) return () => {};
  const oldHTML = btn.innerHTML;
  const oldDisabled = btn.disabled;

  btn.disabled = true;
  btn.innerHTML = `<i class="fas fa-spinner fa-spin me-1"></i>${loadingText || "Processing‚Ä¶"}`;

  return () => {
    btn.innerHTML = oldHTML;
    btn.disabled = oldDisabled;
  };
}


  // ---- config / globals ----
  const CLOSE_HOUR = 24;
  const MAX_LOOKAHEAD_DAYS = 1; // increase if you want to span more days
  let currentStep = 0;
  const TIMES_OWNER = 'times-v2';
  let timeBuildTicket = 0; // SINGLE-FLIGHT TICKET (global)
   window.bookingTotalAmount = 400;

const backArrow = document.getElementById("bookingBackArrow");

if (backArrow) {
  backArrow.addEventListener("click", () => {
    if (currentStep > 0) {
      currentStep--;
      showStep(currentStep);
    }
  });
}

function updateBackArrow(){
  const backArrow = document.getElementById("bookingBackArrow");
  if (!backArrow) return;
  backArrow.style.display = (currentStep === 0) ? "none" : "inline-flex";
}


  // ---- dom refs ----
  const steps = document.querySelectorAll('.form-step');
  const stepIndicators = document.querySelectorAll('.step');
  const nextButtons = document.querySelectorAll('.next-step');
  const prevButtons = document.querySelectorAll('.prev-step');
  const navButtonContainers = document.querySelectorAll('[class^="nav-buttons-step"]');
  const dealerCheckbox = document.getElementById('dealerService');
  const serviceCheckbox = document.getElementById('servicePersonal');
  const drinksCheckbox  = document.getElementById('drinksFlatrate');
  const bookingDateInput = document.getElementById('bookingDate');
  const bookingTimeInput = document.getElementById('bookingTime');
  const bookingDuration  = document.getElementById('bookingDuration');
  const bookingForm = document.getElementById('bookingForm');


  // ---- i18n helper ----
  const _ = (window.gettext || ((s)=>s));

  // ---- time utils ----
  function timeToMinutes(t){ const [H,M]=t.split(':').map(Number); return H*60+(M||0); }
  function minutesToHHMM(mins){ const h=Math.floor(mins/60), m=mins%60; return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; }
  function prevDateISO(dateStr){ const [y,m,d]=dateStr.split('-').map(Number); const dt=new Date(Date.UTC(y,m-1,d)); dt.setUTCDate(dt.getUTCDate()-1); return dt.toISOString().slice(0,10); }
  function addDaysISO(dateStr, days){ const [y,m,d]=dateStr.split('-').map(Number); const dt=new Date(Date.UTC(y,m-1,d)); dt.setUTCDate(dt.getUTCDate()+days); return dt.toISOString().slice(0,10); }

  function parseBookingDateToLocalDate(value) {
  if (!value) return null;

  // Accept "YYYY-MM-DD" or "DD.MM.YYYY"
  if (value.includes("-")) {
    const [y, m, d] = value.split("-").map(Number);
    if (!y || !m || !d) return null;
    return new Date(y, m - 1, d);
  }

  if (value.includes(".")) {
    const [d, m, y] = value.split(".").map(Number);
    if (!y || !m || !d) return null;
    return new Date(y, m - 1, d);
  }

  return null;
}

function isWithin2DaysFromToday(dateObj) {
  if (!dateObj) return false;

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const booking = new Date(dateObj);
  booking.setHours(0, 0, 0, 0);

  const diffMs = booking - today;
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  // today (0), tomorrow (1), day after tomorrow (2)
  return diffDays >= 0 && diffDays <= 2;
}

  function showFieldError(inputEl, message) {
  if (!inputEl) return;

  // remove existing message (if any)
  const existing = inputEl.parentNode.querySelector('.error-message');
  if (existing) existing.remove();

  const err = document.createElement('div');
  err.className = 'error-message text-danger mt-1 small';
  err.textContent = message;
  inputEl.parentNode.appendChild(err);

  inputEl.classList.add('is-invalid');
}

function clearFieldError(inputEl) {
  if (!inputEl) return;
  const existing = inputEl.parentNode.querySelector('.error-message');
  if (existing) existing.remove();
  inputEl.classList.remove('is-invalid');
}

  function normalizeUnavailable(list){
    return (list||[]).map(s=>({ start: timeToMinutes(s.start_time), end: timeToMinutes(s.end_time) }));
  }
  function splitOvernightRange(r){
    if (r.end >= r.start) return [r];
    return [ {start:r.start, end:1440}, {start:0, end:r.end} ];
  }
  function mergeRanges(ranges){
    if (!ranges || !ranges.length) return [];
    const sorted = ranges.slice().sort((a,b)=> a.start-b.start || a.end-b.end);
    const out = [ {...sorted[0]} ];
    for (let i=1;i<sorted.length;i++){
      const prev = out[out.length-1], cur = sorted[i];
      if (cur.start <= prev.end) prev.end = Math.max(prev.end, cur.end);
      else out.push({...cur});
    }
    return out;
  }

  async function getMergedUnavailableForDate(dateStr){
    const res = await fetch('/bookings/get_unavailable_slots?date=' + encodeURIComponent(dateStr));
    const data = await res.json();
    return mergeRanges(normalizeUnavailable(data.unavailable_slots));
  }

  // ---- ui helpers ----
  function updateStepIndicators(){
    stepIndicators.forEach((el,idx)=>{
      el.className = (idx < currentStep) ? 'step completed' : (idx === currentStep ? 'step active' : 'step pending');
    });
    navButtonContainers.forEach((c,idx)=> c.style.display = (idx===currentStep?'block':'none'));
  }


// global cache
window.settingsForDate = null;
let settingsFetchDoneFor = null;

async function fetchReservationSettingsForDate(dateStr){
  if (!dateStr) return null;

  const url = `/bookings/reservation-settings/?date=${encodeURIComponent(dateStr)}`;
  const res = await fetch(url, { headers: { "X-Requested-With": "XMLHttpRequest" } });

  // IMPORTANT: if backend returns HTML error page -> avoid JSON.parse crash
  const ct = res.headers.get("content-type") || "";
  if (!ct.includes("application/json")) {
    const text = await res.text();
    throw new Error("Settings endpoint did not return JSON. Got: " + text.slice(0, 80));
  }

  const data = await res.json();
  if (!res.ok || !data.ok) {
    throw new Error(data.error || "Could not load reservation settings");
  }

  window.settingsForDate = data.settings;     // e.g. { cash_cutoff_days: 3 }
  settingsFetchDoneFor = dateStr;
  return window.settingsForDate;
}

function getCashCutoffDays() {
  // ‚úÖ prefer fetched value (only after Next click)
  const v = window.settingsForDate?.cash_cutoff_days;
  if (typeof v === "number") return v;

  // fallback (so page doesn't break)
  return 2; // default until fetched
}

function updatePricing() {

const PRICING = JSON.parse(document.getElementById("pricing-config").textContent);


  const VAT = parseFloat(PRICING.vat_rate); // 0.19
  const GROSS_DAY = parseFloat(PRICING.gross_day_rental);
  const GROSS_DEALER = parseFloat(PRICING.gross_dealer);
  const GROSS_SERVICE = parseFloat(PRICING.gross_service);
  const GROSS_DRINKS = parseFloat(PRICING.gross_drinks_flatrate);
  const DEPOSIT = parseFloat(PRICING.deposit_amount);

  const dealerOn = !!dealerCheckbox?.checked;
  const serviceOn = !!serviceCheckbox?.checked;
  const drinksOn = !!drinksCheckbox?.checked;

  let grossTotal = GROSS_DAY;
  if (dealerOn) grossTotal += GROSS_DEALER;
  if (serviceOn) grossTotal += GROSS_SERVICE;
  if (drinksOn) grossTotal += GROSS_DRINKS;
  const finalDrinksCost = document.getElementById("finalDrinksCost");
  if (finalDrinksCost) finalDrinksCost.style.display = drinksOn ? "flex" : "none";
const bookingDateValue = document.getElementById("bookingDate")?.value;
const bookingDateObj = parseBookingDateToLocalDate(bookingDateValue);
const lastMinute = isWithin2DaysFromToday(bookingDateObj);

const optionBlock = document.getElementById("bookingAmountOptionBlock");
const lastMinuteNote = document.getElementById("lastMinuteNote");
const includeCheckbox = document.getElementById("includeBookingAmount");
window.grossBookingTotal = grossTotal;

// Re-check promo whenever total changes (even if promo was previously invalid)
const inp = document.getElementById("promoCodeInput");
const normalizedInput = (inp?.value || "").trim().toUpperCase();

if (normalizedInput && promoLooksComplete(normalizedInput)) {
  if (!window.__promoReapplyInFlight && window.__promoLastGrossTotal !== grossTotal) {

    window.__promoLastGrossTotal = grossTotal;
    window.__promoReapplyInFlight = true;

    applyPromoToCurrentTotal(normalizedInput)
      .catch(() => {})
      .finally(() => { window.__promoReapplyInFlight = false; });
  }
}



// If last-minute: hide option + force include booking amount
if (lastMinute) {
  if (optionBlock) optionBlock.style.display = "none";
  if (lastMinuteNote) lastMinuteNote.style.display = "block";
  if (includeCheckbox) {
    includeCheckbox.checked = true;
    includeCheckbox.disabled = true;
  }
} else {
  if (optionBlock) optionBlock.style.display = "block";
  if (lastMinuteNote) lastMinuteNote.style.display = "none";
  if (includeCheckbox) {
    includeCheckbox.disabled = false;
  }
}

const includeBooking = lastMinute ? true : (includeCheckbox?.checked ?? true);
  // ‚úÖ compute what will be charged
  const promoDiscount = Number(window.appliedPromoDiscount || 0);
  const discountedBookingTotal = Math.max(0, grossTotal - promoDiscount);

  // charge = discounted booking total + deposit
  const chargedNow = discountedBookingTotal + DEPOSIT;

  const discountRow = document.getElementById("finalDiscountRow");
const discountAmount = document.getElementById("finalDiscountAmount");

if (discountRow && discountAmount) {
  if (promoDiscount > 0.0001) {
    discountRow.style.display = "flex";
    discountAmount.textContent = `-‚Ç¨${promoDiscount.toFixed(2)}`;
  } else {
    discountRow.style.display = "none";
  }
}

  // deposit display
  const depEl = document.getElementById("stripeDepositAmount");
  if (depEl) depEl.textContent = `‚Ç¨${DEPOSIT.toFixed(2)}`;

  // booking amount display (optional)
  const bookingEl = document.getElementById("bookingAmount");
  if (bookingEl) bookingEl.textContent = `‚Ç¨${grossTotal.toFixed(2)}`;

  // ‚úÖ THIS must show chargedNow (not grossTotal)
  const totalEl = document.getElementById("finalTotalAmount");
  if (totalEl) totalEl.textContent = `‚Ç¨${chargedNow.toFixed(2)}`;
// ---- Cash availability (only if booking date is MORE than 2 days away) ----
const cashBtn = document.getElementById("payWithCashBtn");
const cashInfo = document.getElementById("cashInfo");

let cashAllowed = false;
const cutoffDays = getCashCutoffDays();
if (bookingDateObj) {
  const today = new Date();
  today.setHours(0,0,0,0);
  const booking = new Date(bookingDateObj);
  booking.setHours(0,0,0,0);

  const diffDays = Math.floor((booking - today) / (1000*60*60*24));
  cashAllowed = diffDays > cutoffDays;
}

if (cashBtn) cashBtn.disabled = !cashAllowed;

// ---- Cash rounding (round UP to nearest 10) ----
const roundUpTo10 = (x) => Math.ceil(x / 10) * 10;

const cashDue = chargedNow;              // booking + deposit
const cashRounded = roundUpTo10(cashDue);
const cashFee = cashRounded - cashDue;

if (cashInfo) {
  if (cashAllowed) {
    const feeIsZero = Math.abs(cashFee) < 0.005; // safe for floating point

    if (feeIsZero) {
      cashInfo.textContent =
        ``;
    } else {
      cashInfo.textContent =
        `Cash total will be rounded up to ‚Ç¨${cashRounded.toFixed(2)} (cash handling fee ‚Ç¨${cashFee.toFixed(2)}).`;
    }
  } else {
cashInfo.textContent =
  `Cash payment is not available for bookings within ${cutoffDays} days. Please pay with Stripe.`;
  }
}


  // store for checkout (optional)
  window.includeBookingAmount = includeBooking;

  window.amountToChargeNow = chargedNow;
}


function bindPricingListeners() {
  // 1) Main service toggles
  ["dealerService", "servicePersonal", "drinksFlatrate"].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener("change", () => {
      updatePricing();
    });
  });

  // 2) If you have other price toggles (add IDs here)
  ["includeBookingAmount"].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener("change", () => updatePricing());
  });

  // 3) If ‚Äúdrinks‚Äù are individual checkboxes that affect price (only if they do!)
  document.querySelectorAll('input[name="drinks"]').forEach(cb => {
    cb.addEventListener("change", () => updatePricing());
  });

  // 4) Promo input itself (optional)
  const promoInp = document.getElementById("promoCodeInput");
  if (promoInp) {
    promoInp.addEventListener("input", () => {
      // don‚Äôt auto-apply here unless you want; just keeps state fresh
    });
  }
}

// call it once after updatePricing exists
bindPricingListeners();

function showStep(idx) {
  steps.forEach((s, i) => {
    s.classList.toggle("active", i === idx);
  });

  const backArrow = document.getElementById("bookingBackArrow");
  if (backArrow) {
    backArrow.style.display = idx === 0 ? "none" : "flex";
  }

  updateStepIndicators();
  updateBackArrow();
}


async function validateStep(stepIdx){
    const step = steps[stepIdx];
    const inputs = step.querySelectorAll('input:not([type="hidden"]):not([type="checkbox"]), select');
    let ok = true;
    inputs.forEach(input=>{
      const msg = input.parentNode.querySelector('.error-message');
      if (input.hasAttribute('required') && !String(input.value||'').trim()){
        ok=false;
        if(!msg){
          const err = document.createElement('div');
          err.className='error-message text-danger mt-1 small';
          err.textContent='This field is required.';
          input.parentNode.appendChild(err);
        }
        input.classList.add('is-invalid');
      } else {
        msg && msg.remove();
        input.classList.remove('is-invalid');
      }
    });
    // ‚¨áÔ∏è ADD THIS BLOCK
  // ‚úÖ Step 2: Number of people must be 1‚Äì50
if (stepIdx === 1) {
  const peopleInput = document.getElementById("numberOfPeople");
  const val = parseInt(peopleInput?.value, 10);

  if (!peopleInput?.value || Number.isNaN(val)) {
    ok = false;
    showFieldError(peopleInput, _("Please enter number of people."));
  } else if (val < 1) {
    ok = false;
    showFieldError(peopleInput, _("Minimum is 1 person."));
  } else if (val > 50) {
    ok = false;
    showFieldError(peopleInput, _("Maximum capacity is 50 people."));
  } else {
    clearFieldError(peopleInput);
  }
}

    if (stepIdx === 0 && window.dateAtSixUnavailable) {
    return false;
  }
    // NEW: Check terms checkbox on step 3 (payment step) - stepIdx === 2
    if (stepIdx === 2) {
      const termsCheckbox = document.getElementById('agreeTerms');
      const termsError = document.getElementById('termsError');
      
      if (termsCheckbox && !termsCheckbox.checked) {
        ok = false;
        termsError.classList.remove('d-none');
        termsCheckbox.classList.add('is-invalid');
      } else if (termsCheckbox) {
        termsError.classList.add('d-none');
        termsCheckbox.classList.remove('is-invalid');
      }
    }

    if (stepIdx===0 && ok){
      // ...existing step 0 validation code...
    }
    return ok;
}
async function rebuildTimeDropdownForDate(dateStr){
  const myTicket = ++timeBuildTicket;                // single-flight
  const stillMine = () => myTicket === timeBuildTicket;

  const tSel = bookingTimeInput;
  const dSel = bookingDuration;
  const _ = (window.gettext || (s=>s));

  // reset start-time select
  tSel.innerHTML = '';
  const ph = document.createElement('option');
  ph.value = ''; ph.disabled = true; ph.selected = true;
  ph.textContent = _('Select Time');
  ph.dataset.owner = TIMES_OWNER;
  tSel.appendChild(ph);

  // --- lock to prevent other scripts from repopulating ---
  let lockActive = true;
  const snapshotHTML = () => tSel.innerHTML;
  let lastGood = snapshotHTML();

  const mo = new MutationObserver(() => {
    if (!lockActive) return;
    // if anything not owned by us shows up, revert
    const onlyOurs = Array.from(tSel.options).every(o => o.dataset.owner === TIMES_OWNER);
    if (!onlyOurs) tSel.innerHTML = lastGood;
  });
  mo.observe(tSel, {childList: true, subtree: true});
  // -------------------------------------------------------

  try {
    // today
    const todayRes = await fetch('/bookings/get_unavailable_slots?date=' + encodeURIComponent(dateStr));
    if (!stillMine()) return;
    const todayData = await todayRes.json();
    if (!stillMine()) return;
    let todayRanges = normalizeUnavailable(todayData.unavailable_slots);

    // carry from yesterday (overnight segments)
    try {
      const yday = prevDateISO(dateStr);
      const yRes = await fetch('/bookings/get_unavailable_slots?date=' + encodeURIComponent(yday));
      if (!stillMine()) return;
      const yData = await yRes.json();
      if (!stillMine()) return;
    const yRanges = normalizeUnavailable(yData.unavailable_slots);
    for (const r of yRanges) {
      // only if it actually wraps past midnight (end < start)
      if (r.end < r.start) {
        const parts = splitOvernightRange(r); // [ {start..1440}, {0..end} ]
        // carry only the second part (00:00..end) into today
        if (parts[1] && parts[1].end > 0) {
          todayRanges.push(parts[1]);
        }
      }
    }

    } catch(e) { console.warn('prev-day fetch failed:', e); }

    // split+clip overnight, clean, merge, dedupe
    const flat = [];
    for (const r of todayRanges){
      for (const p of splitOvernightRange(r)){
        if (p.end > 0 && p.start < 1440){
          flat.push({start: Math.max(0,p.start), end: Math.min(1440,p.end)});
        }
      }
    }
const cleaned = flat
  .filter(r => r.end > r.start)               // drop zero/negative
  .map(r => ({
    start: Math.max(0, Math.min(1440, r.start)),
    end:   Math.max(0, Math.min(1440, r.end))
  }))
  .sort((a,b) => a.start - b.start || a.end - b.end);

    let dayUnavailable = mergeRanges(cleaned);
console.log('[dayUnavailable]',
  dayUnavailable.map(r => `${minutesToHHMM(r.start)}-${minutesToHHMM(r.end)}`));

    const seen = new Set();
    dayUnavailable = dayUnavailable.filter(r=>{
      const key = r.start + ':' + r.end;
      if (seen.has(key)) return false;
      seen.add(key); return true;
    });

    // render, keeping order
    const openMin = 0, closeMin = CLOSE_HOUR * 60;
    let cursor = openMin, i = 0;

    while (cursor < closeMin){
      const block = dayUnavailable[i];

      if (block && block.start <= cursor && cursor < block.end){
        // inside booked block -> one disabled line
  const bookedStart = block.start;
  const bookedEnd = Math.min(block.end, closeMin);
        const label = `${minutesToHHMM(bookedStart)} ${_('to')} ${minutesToHHMM(bookedEnd)} (${_('Booked')})`;

        const opt = document.createElement('option');
        opt.value = ''; opt.disabled = true; opt.textContent = label;
        opt.dataset.owner = TIMES_OWNER;
        tSel.appendChild(opt);

  cursor = Math.ceil(bookedEnd / 60) * 60;
  if (cursor >= block.end) i++;
  continue;
      }

      if (block && cursor < block.start){
        // free hours until next block
        while (cursor < Math.min(block.start, closeMin)){
          const opt = document.createElement('option');
          opt.value = minutesToHHMM(cursor);

          opt.textContent = minutesToHHMM(cursor);
          opt.dataset.owner = TIMES_OWNER;
          tSel.appendChild(opt);
          cursor += 60;
        }
        continue;
      }

      if (!block){
        // no more blocks today -> free to close
        while (cursor < closeMin){
          const opt = document.createElement('option');
          opt.value = minutesToHHMM(cursor);
          opt.textContent = minutesToHHMM(cursor);
          opt.dataset.owner = TIMES_OWNER;
          tSel.appendChild(opt);
          cursor += 60;
        }
      }
    }

    lastGood = snapshotHTML(); // freeze our good state
  } catch(e){
    console.error('rebuildTimeDropdownForDate error:', e);
  } finally {
    // let our list "win" for ~1s, then unlock
    setTimeout(()=>{ lockActive = false; mo.disconnect(); }, 1000);
  }

  // reset durations placeholder
  if (dSel) {
    dSel.innerHTML = '';
  const dph = document.createElement('option');
  dph.value=''; dph.disabled=true; dph.selected=true;
  dph.textContent = _('Select Time First');
  dph.dataset.owner = TIMES_OWNER;
  dSel.appendChild(dph);
  }
}


  // ---- durations builder (with next-day look-ahead) ----
  if (!bookingTimeInput.dataset.boundDur){
    bookingTimeInput.dataset.boundDur='1';
    bookingTimeInput.addEventListener('change', async () => {
      const dateVal = bookingDateInput?.value;
      const timeVal = bookingTimeInput?.value;
      if (!dateVal || !timeVal) return;

      const em = bookingDateInput.parentNode.querySelector('.availability-error');
      em && em.remove();
      bookingTimeInput.classList.remove('is-invalid');

      function buildDurationOptions(maxHours, messageIfNone){
        bookingDuration.innerHTML='';
        const ph = document.createElement('option');
        ph.value=''; ph.disabled=true; ph.selected=true; ph.dataset.owner='durations-v2';
        ph.textContent = _('Select hours');
        bookingDuration.appendChild(ph);

        if (maxHours<=0){
          const o = document.createElement('option');
          o.value=''; o.disabled=true; o.dataset.owner='durations-v2';
          o.textContent = messageIfNone || _('No duration available from this start time');
          bookingDuration.appendChild(o);
          return;
        }
        for (let h=1; h<=maxHours; h++){
          const o = document.createElement('option');
          o.value=String(h); o.textContent=String(h); o.dataset.owner='durations-v2';
          bookingDuration.appendChild(o);
        }
      }

      buildDurationOptions(0, _('Loading‚Ä¶'));

      try{
        const resp = await fetch('/bookings/get_unavailable_slots?date=' + encodeURIComponent(dateVal));
        const data = await resp.json();
        const merged = mergeRanges(normalizeUnavailable(data.unavailable_slots));

        const startHHMM = timeVal.slice(0,5);
        const [H,M] = startHHMM.split(':').map(Number);
        const selectedStartMin = H*60 + (M||0);
        const dayCloseMin = CLOSE_HOUR*60;

        // inside a block ‚Üí none
        const inside = merged.some(b => selectedStartMin >= b.start && selectedStartMin < b.end);
        if (inside){ buildDurationOptions(0); return; }

        // next same-day block
        let nextBlockStart = dayCloseMin;
        for (const b of merged){ if (b.start >= selectedStartMin){ nextBlockStart = b.start; break; } }

        let freeUntilNext = nextBlockStart - selectedStartMin;

        // look ahead into following days (up to MAX_LOOKAHEAD_DAYS)
        if (nextBlockStart === dayCloseMin){
          for (let off=1; off<=MAX_LOOKAHEAD_DAYS; off++){
            const probe = addDaysISO(dateVal, off);
            const nextDayMerged = await getMergedUnavailableForDate(probe);
            if (nextDayMerged.length){
              freeUntilNext += (off-1)*dayCloseMin;   // full free days between
              freeUntilNext += nextDayMerged[0].start; // free until earliest busy next day
              break;
            }
            freeUntilNext += dayCloseMin; // whole day free
          }
        }

        const maxHours = Math.max(0, Math.floor(freeUntilNext/60));
        buildDurationOptions(maxHours);

      }catch(e){
        console.error('[durations] build error', e);
        buildDurationOptions(0, _('Unable to load durations'));
      }
    });
  }

  // ---- wire up rest of UI ----
  dealerCheckbox?.addEventListener('change', updatePricing);
  serviceCheckbox?.addEventListener('change', updatePricing);
  drinksCheckbox?.addEventListener('change', updatePricing);
  drinksCheckbox?.addEventListener('change', updatePricing);
  document.getElementById("bookingDate")?.addEventListener("change", updatePricing);



nextButtons.forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    btn.disabled = true;
    const prevHTML = btn.innerHTML;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Checking...';

    try{
      const ok = await validateStep(currentStep);
      if (!ok) return;

      // ‚úÖ ONLY when leaving step 1 (your step index 0)
      if (currentStep === 1) {
        const dateStr = document.getElementById("bookingDate")?.value;

        // loader text change
        btn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Loading settings...';

        // fetch ONCE for selected date
        await fetchReservationSettingsForDate(dateStr);

        // now pricing can safely use window.settingsForDate
        updatePricing();
      }

      if (currentStep < steps.length - 1) {
        currentStep++;
        showStep(currentStep);
        updatePricing();
      }
    } catch (e) {
      console.error(e);
      alert(e.message || String(e));
    } finally {
      btn.disabled = false;
      btn.innerHTML = prevHTML;
    }
  });
});

  prevButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if (currentStep>0){ currentStep--; showStep(currentStep); }
    });
  });

  if (bookingDateInput){
    bookingDateInput.addEventListener('change', async ()=>{
      const err = bookingDateInput.parentNode.querySelector('.availability-error');
      err && err.remove();
      bookingDateInput.classList.remove('is-invalid');
      bookingTimeInput?.classList.remove('is-invalid');

      if (!bookingDateInput.value) return;
      try { await rebuildTimeDropdownForDate(bookingDateInput.value);
        Array.from(bookingTimeInput.options).forEach(o=>{
          if (o.dataset.owner !== TIMES_OWNER) o.remove();
        });
      }
      catch(e){ console.error('Failed to rebuild time dropdown:', e); }
    });
  }

  // init
if (bookingForm) {
  bookingForm.addEventListener('submit', function (e) {
    const termsCheckbox = document.getElementById('agreeTerms');
    const termsError = document.getElementById('termsError');

    if (!termsCheckbox || !termsCheckbox.checked) {
      e.preventDefault(); // block the booking
      termsError.classList.remove('d-none');
      termsCheckbox.classList.add('is-invalid');
      termsCheckbox.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  });
}

  function forceFixedSlot() {
    if (bookingTimeInput) {
      bookingTimeInput.innerHTML = '';
      const tOpt = document.createElement('option');
      tOpt.value = '18:00';
      tOpt.textContent = '18:00';
      tOpt.selected = true;
      bookingTimeInput.appendChild(tOpt);
      bookingTimeInput.value = '18:00';
    }

    if (bookingDuration) {
      bookingDuration.innerHTML = '';
      const dOpt = document.createElement('option');
      dOpt.value = '18';
      dOpt.textContent = '18';
      dOpt.selected = true;
      bookingDuration.appendChild(dOpt);
      bookingDuration.value = '18';
    }
  }

  // Run once on load
  forceFixedSlot();

  // Run again whenever date changes (after any other listeners)
  if (bookingDateInput) {
    bookingDateInput.addEventListener('change', () => {
      forceFixedSlot();
    });
  }
showStep(currentStep);
updatePricing();
updateStepIndicators();

const stripePayBtn = document.getElementById("payWithStripeBtn");
const termsCheckbox = document.getElementById("agreeTerms");
const payWithStripeBtn = document.getElementById("payWithStripeBtn");
const payWithCashBtn   = document.getElementById("payWithCashBtn");
const cashInfo         = document.getElementById("cashInfo");

if (payWithCashBtn) {
  payWithCashBtn.addEventListener("click", async () => {
    // Terms check (keep your existing behavior)
    if (stripePayBtn?.dataset.enabled !== "true") {
      document.getElementById("termsError")?.classList.remove("d-none");
      document.getElementById("agreeTerms")?.scrollIntoView({ behavior: "smooth", block: "center" });
      return;
    }

    const restoreCashBtn = setBtnLoading(payWithCashBtn, "Saving‚Ä¶");
    const restoreStripeBtn = setBtnLoading(payWithStripeBtn, "Please wait‚Ä¶");
    showLoader();

    try {
      const payload = {
        booking_date: document.getElementById("bookingDate")?.value,
        booking_time: "18:00",
        number_of_people: document.getElementById("numberOfPeople")?.value,
        number_of_hours: 18,
        promo_code: document.getElementById("promoCodeHidden")?.value || "",
        user_id: "{{ request.session.user_id|default:'' }}",
        dealer: document.getElementById("dealerService")?.checked || false,
        service: document.getElementById("servicePersonal")?.checked || false,
        drinks_flatrate: document.getElementById("drinksFlatrate")?.checked || false,
        drinks: Array.from(document.querySelectorAll('input[name="drinks"]:checked')).map(x => Number(x.value)),
      };

      const res = await fetch("/payments/pay-with-cash/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": "{{ csrf_token }}",
        },
        body: JSON.stringify(payload),
      });

      const data = await res.json();

      if (!res.ok) {
        hideLoader();
        restoreCashBtn();
        restoreStripeBtn();
        showStripeAlert("danger", data.error || "Cash booking failed.");
        return;
      }

      // ‚úÖ Success message quickly (optional)
      showStripeAlert(
        "success",
        `Cash booking confirmed. Total cash due: ‚Ç¨${data.rounded_cash_due} (fee ‚Ç¨${data.cash_rounding_fee}). Redirecting‚Ä¶`
      );

      // ‚úÖ Redirect to My Bookings
      // Change this URL to your actual "my bookings" page:
      window.location.href = data.redirect_url;

    } catch (err) {
      hideLoader();
      restoreCashBtn();
      restoreStripeBtn();
      showStripeAlert("danger", err?.message || String(err));
    }
  });
}

function syncStripeButtonState() {
  if (!termsCheckbox || !stripePayBtn) return;

  const ok = termsCheckbox.checked;
  stripePayBtn.dataset.enabled = ok ? "true" : "false";

}



// ---- Move Stripe button into sticky nav (Step 3) ----
(function moveStripeButtonToNav() {
  const btn = document.getElementById("payWithStripeBtn");
  const navSlot = document.getElementById("stripePayNavSlot");
  const inlineWrap = document.getElementById("stripePayInlineWrap");

  if (!btn || !navSlot) return;

  // Make it fit nicely next to Back
  btn.classList.remove("w-100");
  btn.classList.add("w-100"); // keep full width inside its col-6

  // Move the wrapper (keeps layout clean)
  if (inlineWrap) {
    navSlot.appendChild(inlineWrap);
  } else {
    navSlot.appendChild(btn);
  }
})();

// Initial state
syncStripeButtonState();

// React on checkbox change
termsCheckbox.addEventListener("change", () => {
  document.getElementById("termsError")?.classList.add("d-none");
  termsCheckbox.classList.remove("is-invalid");
  syncStripeButtonState();
});

const stripeAlert = document.getElementById("stripePaymentAlert");

function showStripeAlert(type, text) {
  if (!stripeAlert) return;
  stripeAlert.className = `alert alert-${type} small`; // bootstrap
  stripeAlert.textContent = text;
  stripeAlert.classList.remove("d-none");
}

async function startStripeCheckout() {
  window.user_id = "{{ request.session.user_id|default:'' }}";
  const user_id = "{{ request.session.user_id|default:'' }}";
  const resp = await fetch("/payments/create-checkout-session/", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-CSRFToken": "{{ csrf_token }}",
    },
    body: JSON.stringify({
      currency: "eur",
      booking_date: document.getElementById("bookingDate")?.value,
      booking_time: "18:00",
      number_of_people: document.getElementById("numberOfPeople")?.value,
      number_of_hours: 18,
      user_id: user_id,
      dealer: document.getElementById("dealerService")?.checked || false,
      service: document.getElementById("servicePersonal")?.checked || false,
      drinks_flatrate: document.getElementById("drinksFlatrate")?.checked || false,
      promo_code: document.getElementById("promoCodeHidden")?.value || "",
    }),
  });

  // If you ever see: Unexpected token '<' ... it means backend returned HTML (500/403 page)
  const data = await resp.json();

  if (!resp.ok || !data.url) {
    throw new Error(data.error || "Could not start Stripe Checkout.");
  }

  window.location.href = data.url;
}

if (stripePayBtn) {
  stripePayBtn.addEventListener("click", async () => {
    if (stripePayBtn.dataset.enabled !== "true") {
      document.getElementById("termsError")?.classList.remove("d-none");
      document.getElementById("agreeTerms")?.scrollIntoView({
        behavior: "smooth",
        block: "center"
      });
      return;
    }

    try {
      await startStripeCheckout();
    } catch (err) {
      showStripeAlert("danger", err.message || String(err));
    }
  });
}

window.updatePricing = updatePricing;

});

// =======================
// PROMO (NO BUTTON) AUTO APPLY + CLEAR ON EDIT
// =======================

function getCSRFToken() {
  return document.querySelector('input[name="csrfmiddlewaretoken"]')?.value || "";
}

function clearPromoUIOnly() {
  const promoMsg = document.getElementById("promoMsg");
  if (promoMsg) {
    promoMsg.className = "small mt-1";
    promoMsg.textContent = "";
  }

  // clear cached values
  window.appliedPromoCode = "";
  window.appliedPromoDiscount = 0;

  // hidden fields (so backend doesn‚Äôt get stale promo)
  const promoHidden = document.getElementById("promoCodeHidden");
  const discHidden = document.getElementById("promoDiscountHidden");
  if (promoHidden) promoHidden.value = "";
  if (discHidden) discHidden.value = "0";

  // hide discount row
  const discountRow = document.getElementById("finalDiscountRow");
  if (discountRow) discountRow.style.display = "none";
}

window.__promoReapplyInFlight = false;
window.__promoLastGrossTotal = null;

function setPromoState({ code = "", discount = 0, ok = false, message = "" }) {
  const promoMsg = document.getElementById("promoMsg");
  const promoHidden = document.getElementById("promoCodeHidden");
  const discHidden = document.getElementById("promoDiscountHidden");

  if (promoHidden) promoHidden.value = ok ? code : "";
  if (discHidden) discHidden.value = ok ? String(discount) : "0";

  window.appliedPromoCode = ok ? String(code).trim().toUpperCase() : "";
  window.appliedPromoDiscount = ok ? Number(discount) : 0;

  if (promoMsg) {
    promoMsg.textContent = message || "";
  }
}

function clearAppliedPromoDiscount() {
  // promo is no longer applied
  window.promoDiscount = 0;
  window.appliedPromoCode = null;

  // hide discount row
  const discountRow = document.getElementById("finalDiscountRow");
  const discountAmount = document.getElementById("finalDiscountAmount");
  if (discountRow) discountRow.style.display = "none";
  if (discountAmount) discountAmount.textContent = "-‚Ç¨0.00";

  // recompute total back to gross
  // (IMPORTANT: use the latest grossTotal that updatePricing sets)
  const grossTotal = window.bookingTotalAmount || 0;

  const totalAmountEl = document.getElementById("totalAmount");
  if (totalAmountEl) totalAmountEl.textContent = `‚Ç¨${grossTotal.toFixed(2)}`;

  const finalTotalEl = document.getElementById("finalTotalAmount");
  if (finalTotalEl) finalTotalEl.textContent = `‚Ç¨${grossTotal.toFixed(2)}`;
}

function promoLooksComplete(code) {
  return code.length >= 5;
}

let promoDebounceTimer = null;
let lastRequestedCode = "";

async function applyPromoToCurrentTotal(code) {
  // gross total without deposit (you already set this in updatePricing)
  const grossTotal = Number(window.grossBookingTotal || 0);
  if (!grossTotal || grossTotal <= 0) {
    // totals not ready yet, just clear
    clearPromoUIOnly();
    window.updatePricing?.();
    return;
  }

  lastRequestedCode = code;

  const res = await fetch("/promotions/apply/", {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "X-CSRFToken": getCSRFToken(),
    },
    body: new URLSearchParams({
      code: code,
      gross_total: String(grossTotal),
    }),
  });

  const data = await res.json();

  // If user typed something else while request was in-flight, ignore response
  const current = (document.getElementById("promoCodeInput")?.value || "").trim().toUpperCase();
  if (current !== lastRequestedCode) return;

  if (!data.ok) {
if (data.error?.code === "min_total_not_met") {
  const min = parseFloat(data.error.min_required);
  const cur = parseFloat(data.error.current_total);
  const remaining = Math.max(0, min - cur);

  // keep the user's code for later re-validation (optional)
  window.enteredPromoCode = code;

  // ‚úÖ IMPORTANT: clear the *applied* promo state properly
  setPromoState({
    ok: false,
    code: "",       // not applied
    discount: 0,
    message: ""
  });

  // show warning message
  showPromoMessage(
    `Add ‚Ç¨${remaining.toFixed(2)} more to use this promo (minimum ‚Ç¨${min.toFixed(2)}).`,
    "warning"
  );

  // recompute totals WITHOUT discount
  window.updatePricing?.();
  return;
}



  // fallback
  showPromoMessage("Invalid promo code", "error");
  return;
}

if (window.__promoMinRequired) {
  const remaining = window.__promoMinRequired - grossTotal;
  if (remaining > 0) {
    showPromoMessage(
      `Add ‚Ç¨${remaining.toFixed(2)} more to use this promo.`,
      "warning"
    );
  }
}

function showPromoMessage(text, type = "info") {
  const el = document.getElementById("promoMsg");
  if (!el) return;

  el.textContent = text;
  el.className = `promo-hint ${type}`;
}

  const discount = Number(data.discount_gross || 0);

  setPromoState({
    ok: true,
    code: data.code,
    discount,
    message: ""
  });
showPromoMessage(
  `Applied: ${data.code} (‚àí‚Ç¨${discount.toFixed(2)})`,
  "success"
);
  window.updatePricing?.();
}

// ‚úÖ Auto-apply on typing (no button)
document.getElementById("promoCodeInput")?.addEventListener("input", (e) => {
  const input = e.target;

  // normalize
  let code = (input.value || "").toUpperCase().replace(/\s+/g, "");
  input.value = code;

  // IMPORTANT UX: clear message immediately when user edits
  clearPromoUIOnly();
  window.updatePricing?.();

  if (!code) return;

  // debounce backend calls
  if (promoDebounceTimer) clearTimeout(promoDebounceTimer);

  promoDebounceTimer = setTimeout(() => {
    if (promoLooksComplete(code)) {
      applyPromoToCurrentTotal(code).catch(() => {
        
      });
    }
  }, 350);
});

// Optional: pressing Enter applies immediately
document.getElementById("promoCodeInput")?.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    const code = (e.target.value || "").trim().toUpperCase();
    clearPromoUIOnly();
    window.updatePricing?.();
    if (code && promoLooksComplete(code)) {
      applyPromoToCurrentTotal(code).catch(() => {
        
      });
    }
  }
});

</script>
